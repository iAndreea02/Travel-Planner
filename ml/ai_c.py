# -*- coding: utf-8 -*-
"""Ai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oJZViJpCrDbthP6xBu2ZRKRKRrTVTtgC

Inceputuri

# Colectarea de date
"""

import requests
import pandas as pd
import time
import random

api_key = "5ae2e3f221c38a28845f05b6d39ea85b65163d209754a67b5f62156e"

orase = ["Bucharest", "Cluj-Napoca", "Timisoara", "Iasi", "Constanta",
         "Brasov", "Oradea", "Sibiu", "Targu Mures", "Craiova", "Galati", "Suceava"]

toate_locatiile = []

for oras in orase:
    print(f"游늸 Caut 칥n {oras}")

    geo = requests.get(
        f"https://api.opentripmap.com/0.1/en/places/geoname?name={oras}&apikey={api_key}"
    ).json()

    lat, lon = geo.get("lat"), geo.get("lon")

    if not lat or not lon:
        print(f"丘멆잺 Nu am g캒sit coordonate pentru {oras}. Sar peste...")
        continue

    radius_url = f"https://api.opentripmap.com/0.1/en/places/radius?radius=10000&lon={lon}&lat={lat}&limit=100&apikey={api_key}"
    features = requests.get(radius_url).json().get("features", [])

    for f in features:
        xid = f["properties"]["xid"]
        detail_url = f"https://api.opentripmap.com/0.1/en/places/xid/{xid}?apikey={api_key}"
        detail = requests.get(detail_url).json()

        if not detail.get("name"):
            continue

        rate = detail.get("rate", "")
        popularitate = {"3h": 3, "2h": 2, "1h": 1}.get(rate, 0)

        rating_general = round(random.uniform(3.5, 5.0), 1)
        nr_recenzii = random.randint(50, 3000)

        categorii = detail.get("kinds", "")
        categorie = categorii.split(",")[0].replace("_", " ").capitalize() if categorii else "Necunoscut"
        categorie_lc = categorie.lower()

        # Sezon
        if "beaches" in categorie_lc or "coast" in categorie_lc:
            sezon = "Cald"
        elif "ski" in categorie_lc or "mountain" in categorie_lc:
            sezon = "Rece"
        elif "museum" in categorie_lc or "architecture" in categorie_lc:
            sezon = "Oric칙nd"
        else:
            sezon = random.choice(["Cald", "Rece", "Oric칙nd"])

        # Pret estimativ
        if "museum" in categorie_lc:
            pret = random.randint(20, 60)
        elif "amusement" in categorie_lc:
            pret = random.randint(50, 100)
        elif "thermal" in categorie_lc or "spa" in categorie_lc:
            pret = random.randint(70, 150)
        elif "park" in categorie_lc or "nature" in categorie_lc:
            pret = 0
        elif "religious" in categorie_lc or "monastery" in categorie_lc:
            pret = random.choice([0, 10])
        else:
            pret = random.randint(10, 50)

        if pret == 0:
            pret_categorie = "Gratuit"
        elif pret <= 30:
            pret_categorie = "Mic"
        elif pret <= 70:
            pret_categorie = "Mediu"
        else:
            pret_categorie = "Mare"

        # Tip calatorie
        if any(kw in categorie_lc for kw in ["museum", "architecture", "urban"]):
            tip_calatorie = "City Break"
        elif any(kw in categorie_lc for kw in ["park", "nature", "mountain", "lake"]):
            tip_calatorie = "Relaxare"
        elif any(kw in categorie_lc for kw in ["thermal", "spa", "amusement", "beach"]):
            tip_calatorie = "Relaxare"
        elif any(kw in categorie_lc for kw in ["historic", "religious", "monastery"]):
            tip_calatorie = "Circuit"
        else:
            tip_calatorie = random.choice(["City Break", "Circuit", "Relaxare"])

        # Durata minima (numeric캒)
        if tip_calatorie == "City Break":
            durata_minima = 1
        elif tip_calatorie == "Circuit":
            durata_minima = 5
        else:
            durata_minima = 2

        # Cuvinte cheie pentru loca탵ie
        cuvinte_cheie = []

        if "religion" in categorie_lc:
            cuvinte_cheie = ["religios", "spiritual", "biseric캒", "m캒n캒stire", "credin탵캒",]
        elif "historic architecture" in categorie_lc:
            cuvinte_cheie = [ "cl캒diri vechi", "monumente istorice", "istorie", "patrimoniu"]
        elif "historic" in categorie_lc:
            cuvinte_cheie = ["istoric", "cultur캒", "evenimente istorice", "istorie"]
        elif "cinemas" in categorie_lc:
            cuvinte_cheie = ["cinema", "film",  "sal캒 de cinema", "evenimente cinematografice"]
        elif "cultural" in categorie_lc:
            cuvinte_cheie = ["cultur캒", "arte", "expozi탵ie", "festival", "evenimente culturale", "muzic캒", "dans"]
        elif "other" in categorie_lc:
            cuvinte_cheie = ["diverse", "loca탵ie", "interesant", "explorare", "necategorizat", "activit캒탵i diverse"]
        elif "museums" in categorie_lc:
            cuvinte_cheie = ["muzeu", "expozi탵ie", "art캒", "istorie", "cultur캒"]
        elif "architecture" in categorie_lc:
            cuvinte_cheie = ["arhitectur캒", "design", "cl캒diri", "structuri", "construc탵ii", ]
        elif "fountains" in categorie_lc:
            cuvinte_cheie = ["f칙nt칙n캒", "ap캒", "fontan캒", "loc de relaxare", "jocuri de ap캒"]
        elif "palaces" in categorie_lc:
            cuvinte_cheie = ["palat", "monarhie", "regal", "elegan탵캒", "lux"]
        elif "theatres and entertainments" in categorie_lc:
            cuvinte_cheie = ["teatru", "spectacol", "muzic캒", "dans", "entertainment", "divertisment"]
        elif "towers" in categorie_lc:
            cuvinte_cheie = ["turn", "v칙rf", "panoram캒", "priveli탳te"]
        elif "cemeteries" in categorie_lc:
            cuvinte_cheie = ["cemetery", "morm칙nt", "istorie", "cultur캒", "spiritualitate"]
        elif "biographical museums" in categorie_lc:
            cuvinte_cheie = ["muzeu biografic", "via탵a unui om"]
        elif "fortifications" in categorie_lc:
            cuvinte_cheie = ["fortifica탵ie", "castel", "cetate"]
        elif "urban environment" in categorie_lc:
            cuvinte_cheie = ["urban", "ora탳", "str캒zi", "via탵캒 urban캒"]
        elif "gardens and parks" in categorie_lc:
            cuvinte_cheie = ["gr캒dina", "parc", "natur캒", "relaxare", "plimbare"]
        elif "view points" in categorie_lc:
            cuvinte_cheie = ["priveli탳te", "panoram캒", "peisaj"]
        elif "science museums" in categorie_lc:
            cuvinte_cheie = ["muzeu 탳tiin탵ific", "inova탵ie", "tehnologie", "descoperire", "experimente", "inven탵ii"]
        elif "settlements" in categorie_lc:
            cuvinte_cheie = ["a탳ezare", "comunitate", "village", "ora탳", "istorie", "cultura local캒"]
        elif "natural" in categorie_lc:
            cuvinte_cheie = ["natur캒", "conservare", "peisaj natural", "faun캒", "flor캒"]
        elif "beaches" in categorie_lc:
            cuvinte_cheie = ["plaj캒", "soare", "vacan탵캒", "relaxare", "mare", "ocean", "nisip"]
        elif "geological formations" in categorie_lc:
            cuvinte_cheie = ["forme geologice", "munte", "caverne", "pe탳teri"]
        elif "battlefields" in categorie_lc:
            cuvinte_cheie = ["c칙mp de b캒t캒lie", "istorie militar캒", "r캒zboi"]
        elif "bridges" in categorie_lc:
            cuvinte_cheie = ["pod", "construc탵ie", "istoric"]
        else:
            cuvinte_cheie = ["loca탵ie", "descoperire", "activit캒탵i diverse"]

        location = {
            "oras": oras,
            "denumire": detail.get("name"),
            "categorie": categorie,
            "rating_general": rating_general,
            "nr_recenzii": nr_recenzii,
            "pret_categorie": pret_categorie,
            "sezon": sezon,
            "tip_calatorie": tip_calatorie,
            "durata_minima": durata_minima,
            "cuvinte_cheie": cuvinte_cheie,
        }
        toate_locatiile.append(location)
        time.sleep(1)  # Respect캒 limita de API (maxim 1 cerere pe secund캒)

# Creaz캒 DataFrame din lista de loca탵ii
df_locatii = pd.DataFrame(toate_locatiile)

# Salveaz캒 칥n format CSV
df_locatii.to_csv("locatii_turistice.csv", index=False)

# Afi탳eaz캒 primele 5 loca탵ii
print(df_locatii.head())

"""# Normalizarea 탳i preprocesarea datelor:"""

import pandas as pd

df = pd.read_csv("locatii_turistice.csv")
df.head()

"""### Verifificarea si tratarea datelor null"""

df.isnull().sum() #numar cate date sunt null

df=df.dropna()
df.isnull().sum()
# sterg datele nulll si verific daca mai am altele

"""## Tratarea duplicatelor"""

print(df.duplicated())  # Afi탳eaz캒 un True pentru r칙ndurile duplicate

"""## Standardizarea"""

print(df['categorie'].unique())  # Afi탳eaz캒 valorile unice din coloana 'categorie'
print(df['tip_calatorie'].unique())  # Afi탳eaz캒 valorile unice din coloana 'tip_calatorie'

"""## Detectarea 탳i Tratarea Valorilor Aberante"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Calcularea IQR pentru coloana 'rating_general'
Q1 = df['rating_general'].quantile(0.25)
Q3 = df['rating_general'].quantile(0.75)
IQR = Q3 - Q1

# Definirea limitelor pentru valorile aberante
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Detectarea valorilor aberante
outliers = df[(df['rating_general'] < lower_bound) | (df['rating_general'] > upper_bound)]

print("Valorile aberante identificate:", outliers)

"""## Transformam String in Numere

### ~TF-IDF cuvinte cheie (dar cred ca o sa ma razgandesc)~
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_extraction.text import ENGLISH_STOP_WORDS
import nltk
from nltk.stem import WordNetLemmatizer

# Asigur캒-te c캒 ai desc캒rcat resursele necesare pentru lemmatizare
nltk.download('wordnet')
nltk.download('omw-1.4')

# Ini탵ializeaz캒 lemmatizatorul
lemmatizer = WordNetLemmatizer()

# Cuvinte cheie pentru fiecare categorie
categorii = {
    "religion": ["religios", "spiritual", "biseric캒", "m캒n캒stire", "credin탵캒"],
    "historic architecture": ["cl캒diri vechi", "monumente istorice", "istorie", "patrimoniu"],
    "cinemas": ["cinema", "film", "sal캒 de cinema", "evenimente cinematografice"],
    "historic": ["istorie", "cultur캒", "evenimente istorice", "istorie"],
    "cultural": ["cultur캒", "arte", "expozi탵ie", "festival", "evenimente culturale", "muzic캒", "dans"],
    "other": ["diverse", "loca탵ie", "interesant", "explorare", "necategorizat", "activit캒탵i diverse"],
    "museums": ["muzeu", "expozi탵ie", "art캒", "istorie", "cultur캒"],
    "architecture": ["arhitectur캒", "design", "cl캒diri", "structuri", "construc탵ii"],
    "fountains": ["f칙nt칙n캒", "ap캒", "fontan캒", "loc de relaxare", "jocuri de ap캒"],
    "palaces": ["palat", "monarhie", "istorie", "elegan탵캒", "lux"],
    "theatres and entertainments": ["teatru", "spectacol", "muzic캒", "dans", "entertainment", "divertisment", "cultur캒"],
    "towers": ["turn", "v칙rf", "panoram캒", "priveli탳te"],
    "cemeteries": ["cemetery", "morm칙nt", "istorie", "cultur캒", "spiritualitate"],
    "biographical museums": ["muzeu biografic", "via탵a unui om"],
    "fortifications": ["fortifica탵ie", "castel", "cetate", "istorie"],
    "urban environment": ["urban", "ora탳", "via탵캒 urban캒"],
    "gardens and parks": ["gr캒dina", "parc", "natur캒", "relaxare", "plimbare"],
    "view points": ["priveli탳te", "panoram캒", "peisaj", "natur캒"],
    "science museums": ["muzeu stiin탵ific", "inova탵ie", "tehnologie", "descoperire", "experimente", "inven탵ii"],
    "settlements": ["a탳ezare", "comunitate", "village", "ora탳", "istorie", "cultura local캒"],
    "natural": ["natur캒", "conservare", "peisaj natural", "fa콖캒", "flor캒"],
    "beaches": ["plaj캒", "soare", "vacan탵캒", "relaxare", "mare", "ocean", "nisip", "natur캒"],
    "geological formations": ["forme geologice", "munte", "caverne", "pe탳teri", "natur캒"],
    "battlefields": ["c칙mp de b캒t캒lie", "istorie militar캒", "r캒zboi", "istorie"],
    "bridges": ["pod", "construc탵ie", "istorie"]
}

# Func탵ie de preprocesare pentru a elimina stopwords 탳i a lemmatiza cuvintele
def preprocesare(text):
    # Lemmatizeaz캒 fiecare cuv칙nt din text
    text = ' '.join([lemmatizer.lemmatize(word) for word in text.split() if word not in ENGLISH_STOP_WORDS])
    return text

# Preprocesarea datelor: combin캒 toate categoriile 칥ntr-un corpus de text
corpus = [' '.join(cuvinte) for cuvinte in categorii.values()]
corpus = [preprocesare(text) for text in corpus]

# Verific캒 corpusul pentru a observa ce con탵ine
print("Corpusul preprocesat:")
print(corpus)

# Crearea vectorului TF-IDF cu parametrii ajusta탵i
vectorizer = TfidfVectorizer(stop_words=None, ngram_range=(1, 2), max_df=0.85)
X = vectorizer.fit_transform(corpus)

print("\nCorpusul dup캒 preprocesare:")
print(corpus)


# Afi탳area vocabularului (cuvintele unice extrase din corpus)
print("\nVocabularul:")
print(vectorizer.get_feature_names_out())

# Afi탳area scorurilor TF-IDF pentru fiecare categorie
print("\nScoruri TF-IDF:")
print(X.toarray())

import nltk
from sklearn.feature_extraction.text import TfidfVectorizer
import numpy as np

# Dac캒 nu ai desc캒rcat deja stopwords, o po탵i face acum
nltk.download('stopwords')


# Creeaz캒 vectorizatorul TF-IDF
tfidf_vectorizer = TfidfVectorizer(stop_words=nltk.corpus.stopwords.words('romanian'))

# Transform캒 corpusul 칥ntr-o matrice TF-IDF
tfidf_matrix = tfidf_vectorizer.fit_transform(corpus)

# Vocabularul (termenii din corpus)
terms = tfidf_vectorizer.get_feature_names_out()

# Verific캒 scorurile TF-IDF pentru primul document
first_document_scores = tfidf_matrix[0].toarray()[0]

# Afi탳eaz캒 scorurile 탳i cuvintele corespunz캒toare
sorted_indices = np.argsort(first_document_scores)[::-1]

# Afi탳eaz캒 primele 10 scoruri cele mai mari pentru primul document
print("Cele mai importante 10 cuvinte din primul document:")
for index in sorted_indices[:10]:
    print(f"Termen: {terms[index]}, Scor TF-IDF: {first_document_scores[index]}")

# C캒ut캒m scorul pentru un cuv칙nt specific (de exemplu "istorie")
word = 'istorie'  # Exemplu de cuv칙nt pe care vrei s캒-l verifici
if word in terms:
    index_of_word = terms.tolist().index(word)
    word_score = first_document_scores[index_of_word]
    print(f"\nScor TF-IDF pentru '{word}' : {word_score}")
else:
    print(f"\nCuv칙ntul '{word}' nu exist캒 칥n vocabularul generat.")

"""### Bag of Words (BoW) cuvinte-cheie

transf cuvintele cheie in vectori si calculeaza similaritatea intre ceea ce introduce utilizatoru si cuvintele cheie
"""

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Textul utilizatorului
text_utilizator = "Sunt o fire pasionata de cultur캒, ador sa vad cl캒dirile vechi"

# Cuvintele cheie pentru fiecare categorie
cuvinte_cheie = {
    "religion": ["religios", "spiritual", "biseric캒", "m캒n캒stire", "credin탵캒"],
    "historic architecture": ["cl캒diri vechi", "monumente istorice", "istorie", "patrimoniu"],
    "cinemas": ["cinema", "film", "sal캒 de cinema", "evenimente cinematografice"],
    "historic": ["istorie", "cultur캒", "evenimente istorice", "istorie"],
    "cultural": ["cultur캒", "arte", "expozi탵ie", "festival", "evenimente culturale", "muzic캒", "dans"],
    "other": ["diverse", "loca탵ie", "interesant", "explorare", "necategorizat", "activit캒탵i diverse"],
    "museums": ["muzeu", "expozi탵ie", "art캒", "istorie", "cultur캒"],
    "architecture": ["arhitectur캒", "design", "cl캒diri", "structuri", "construc탵ii"],
    "fountains": ["f칙nt칙n캒", "ap캒", "fontan캒", "loc de relaxare", "jocuri de ap캒"],
    "palaces": ["palat", "monarhie", "istorie", "elegan탵캒", "lux"],
    "theatres and entertainments": ["teatru", "spectacol", "muzic캒", "dans", "entertainment", "divertisment", "cultur캒"],
    "towers": ["turn", "v칙rf", "panoram캒", "priveli탳te"],
    "cemeteries": ["cemetery", "morm칙nt", "istorie", "cultur캒", "spiritualitate"],
    "biographical museums": ["muzeu biografic", "via탵a unui om"],
    "fortifications": ["fortifica탵ie", "castel", "cetate", "istorie"],
    "urban environment": ["urban", "ora탳", "via탵캒 urban캒"],
    "gardens and parks": ["gr캒dina", "parc", "natur캒", "relaxare", "plimbare"],
    "view points": ["priveli탳te", "panoram캒", "peisaj", "natur캒"],
    "science museums": ["muzeu stiin탵ific", "inova탵ie", "tehnologie", "descoperire", "experimente", "inven탵ii"],
    "settlements": ["a탳ezare", "comunitate", "village", "ora탳", "istorie", "cultura local캒"],
    "natural": ["natur캒", "conservare", "peisaj natural", "fa콖캒", "flor캒"],
    "beaches": ["plaj캒", "soare", "vacan탵캒", "relaxare", "mare", "ocean", "nisip", "natur캒"],
    "geological formations": ["forme geologice", "munte", "caverne", "pe탳teri", "natur캒"],
    "battlefields": ["c칙mp de b캒t캒lie", "istorie militar캒", "r캒zboi", "istorie"],
    "bridges": ["pod", "construc탵ie", "istorie"]
}

# Transform캒 textul utilizatorului 탳i cuvintele cheie 칥ntr-o list캒 de texte
texte_combinate = [text_utilizator] + [" ".join(keywords) for keywords in cuvinte_cheie.values()]

# Aplicarea CountVectorizer pentru a ob탵ine BoW
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(texte_combinate)

# Calcularea similarit캒탵ii cosinus
similaritati = cosine_similarity(X[0:1], X[1:])

# Afi탳area rezultatelor
for i, categorie in enumerate(cuvinte_cheie):
    print(f"Similaritatea utilizatorului cu categoria '{categorie}': {similaritati[0][i]:.4f}")

"""### One-Hot Encoding: sezon + tip calatorie+pret

transf din numere in text restul de coloane
"""

import pandas as pd
from sklearn.preprocessing import OneHotEncoder
import numpy as np


# One-hot encoding pentru sezon
encoder_sezon = OneHotEncoder(sparse_output=False)
sezon_encoded = encoder_sezon.fit_transform(df[['sezon']])

# One-hot encoding pentru tipul de c캒l캒torie
encoder_tip_calatorie = OneHotEncoder(sparse_output=False)
tip_calatorie_encoded = encoder_tip_calatorie.fit_transform(df[['tip_calatorie']])

# One-hot encoding pentru pre탵
encoder_pret = OneHotEncoder(sparse_output=False)
pret_encoded = encoder_pret.fit_transform(df[['pret_categorie']])

# Crearea unui nou DataFrame cu codific캒rile one-hot
df_sezon_encoded = pd.DataFrame(sezon_encoded, columns=encoder_sezon.categories_[0])
df_tip_calatorie_encoded = pd.DataFrame(tip_calatorie_encoded, columns=encoder_tip_calatorie.categories_[0])
df_pret_encoded = pd.DataFrame(pret_encoded, columns=encoder_pret.categories_[0])

# Ad캒ugarea codific캒rilor la DataFrame-ul original
df = pd.concat([df, df_sezon_encoded, df_tip_calatorie_encoded, df_pret_encoded], axis=1)

# Elimin캒m coloanele originale
df = df.drop(['sezon', 'tip_calatorie', 'pret_categorie'], axis=1)
df.head()

"""## Impartirea datelor in date de antrenare si testare

## Regresia logistica (tre sa refaci zona asta ca nu mere a ramas dupa alg tf-idf)
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Cuvinte cheie pentru fiecare categorie
categorii = {
    "religion": ["religios", "spiritual", "biseric캒", "m캒n캒stire", "credin탵캒"],
    "historic architecture": ["cl캒diri vechi", "monumente istorice", "istorie", "patrimoniu"],
    "cinemas": ["cinema", "film", "sal캒 de cinema", "evenimente cinematografice"],
    "historic": ["istoric", "cultur캒", "evenimente istorice", "istorie"],
    "cultural": ["cultur캒", "arte", "expozi탵ie", "festival", "evenimente culturale", "muzic캒", "dans"],
    "other": ["diverse", "loca탵ie", "interesant", "explorare", "necategorizat", "activit캒탵i diverse"],
    "museums": ["muzeu", "expozi탵ie", "art캒", "istorie", "cultur캒"],
    "architecture": ["arhitectur캒", "design", "cl캒diri", "structuri", "construc탵ii"],
    "fountains": ["f칙nt칙n캒", "ap캒", "fontan캒", "loc de relaxare", "jocuri de ap캒"],
    "palaces": ["palat", "monarhie", "regal", "elegan탵캒", "lux"],
    "theatres and entertainments": ["teatru", "spectacol", "muzic캒", "dans", "entertainment", "divertisment"],
    "towers": ["turn", "v칙rf", "panoram캒", "priveli탳te"],
    "cemeteries": ["cemetery", "morm칙nt", "istorie", "cultur캒", "spiritualitate"],
    "biographical museums": ["muzeu biografic", "via탵a unui om"],
    "fortifications": ["fortifica탵ie", "castel", "cetate"],
    "urban environment": ["urban", "ora탳", "str캒zi", "via탵캒 urban캒"],
    "gardens and parks": ["gr캒dina", "parc", "natur캒", "relaxare", "plimbare"],
    "view points": ["priveli탳te", "panoram캒", "peisaj"],
    "science museums": ["muzeu 탳tiin탵ific", "inova탵ie", "tehnologie", "descoperire", "experimente", "inven탵ii"],
    "settlements": ["a탳ezare", "comunitate", "village", "ora탳", "istorie", "cultura local캒"],
    "natural": ["natur캒", "conservare", "peisaj natural", "faun캒", "flor캒"],
    "beaches": ["plaj캒", "soare", "vacan탵캒", "relaxare", "mare", "ocean", "nisip"],
    "geological formations": ["forme geologice", "munte", "caverne", "pe탳teri"],
    "battlefields": ["c칙mp de b캒t캒lie", "istorie militar캒", "r캒zboi"],
    "bridges": ["pod", "construc탵ie", "istoric"]
}


# Crearea vectorului TF-IDF
vectorizer = TfidfVectorizer(stop_words='english')  # Po탵i ad캒uga un set de stopwords personalizat dac캒 vrei
X = vectorizer.fit_transform(corpus)

# Etichetele corespunz캒toare categoriilor
y = [i for i in range(len(categorii))]  # Fiecare categorie va primi un num캒r unic

# 칉mp캒r탵irea datelor 칥n seturi de antrenament 탳i testare
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Crearea 탳i antrenarea modelului de regresie logistic캒
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)

# Predic탵ii pe setul de test
y_pred = model.predict(X_test)

# Evaluarea performan탵ei modelului
print(f"Accuracy: {accuracy_score(y_test, y_pred)}")
print(f"Classification Report:\n{classification_report(y_test, y_pred)}")

# Testarea modelului pe o descriere nou캒
noua_descriere = ["Plaj캒 cu nisip fin 탳i ap캒 cristalin캒"]
noua_descriere_tfidf = vectorizer.transform(noua_descriere)
pred = model.predict(noua_descriere_tfidf)

# Afi탳캒m categoria prezis캒
categorie_pred = list(categorii.keys())[pred[0]]
print(f"Categoria prezis캒 pentru descrierea nou캒: {categorie_pred}")

"""# Predic탵ia

### ~TF-IDF~
"""

from sklearn.metrics.pairwise import cosine_similarity

# Descrierea utilizatorului (exemplu)
descriere_utilizator = "imi place sa "

# Crearea vectorului TF-IDF pentru descrierea utilizatorului
X_utilizator = vectorizer.transform([descriere_utilizator])

# Calcularea similarit캒탵ii cosinus 칥ntre descrierea utilizatorului 탳i fiecare categorie
similaritati = cosine_similarity(X_utilizator, X)

# G캒sirea categoriei cu cel mai mare scor
index_max = similaritati.argmax()
categorie_predic탵ie = list(categorii.keys())[index_max]

print(f"Categoria recomandat캒 pentru utilizator este: {categorie_predic탵ie}")

"""# Generarea"""